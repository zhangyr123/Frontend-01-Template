# week06
### 有限状态机
1. 一种编程的思想，没有固定的形态或接口（AST/正则/算法）
2. 每一个状态都是一个机器<br>
  1）在每一个机器里，我们可以做计算、存储、输出<br>
  2）所有的这些机器接收的输入是一致的<br>
  3）状态机的每一个机器本身没有状态，如果我们用函数来表示的话，应该是纯函数（无副作用）<br>
3. 每一个机器知道下一个状态<br>
  1）每个机器都有确定的下一个状态（Moore）<br>
  2）每个机器根据输入决定下一个状态（Mealy）<br>
### JS中的有限状态机(Mealy)
```
// 每个函数是一个状态
function state(input) { // 函数参数就是输入
    ... // 在函数中，可以自由地编写代码，处理每个状态的逻辑
    return next // 返回值作为下一个状态
}
```
### 有限状态机处理字符串（Mealy）

## 浏览器工作原理
### html解析
1. 拆分文件：方便文件管理，接受HTML文本作为参数，返回一棵DOM树<br>
2. 创建状态机：<br>
1) 用FSM来实现HTML的分析<br>
2）在HTML标准中，已经规定了HTML的状态<br>
3）toy-Browser只挑选其中一部分状态，完成一个最简版本<br>
3. 解析标签<br>
1）主要的标签：开始标签，结束标签和自封标签<br>
2）这一步暂时忽略属性<br>
4. 创建元素<br>
1）在状态机中，除了状态迁移，还会加入业务逻辑<br>
2）在标签结束状态提交标签token<br>
5. 处理属性<br>
1）属性值分为单引号、双引号、无引号三种写法，因此需要较多状态处理<br>
2）处理属性的方式跟标签类似<br>
3）属性结束时，我们把属性加到标签Token上<br>
6. 创建DOM树<br>
1）从标签构建DOM树的基本技巧是使用栈<br>
2）遇到开始标签时创建元素并入栈，遇到结束标签时出栈<br>
3）自封闭节点可视为入栈后立即出栈<br>
4）任何元素的父元素是它入栈前的栈顶<br>
7. 文本节点<br>
1）文本节点与自封闭标签处理类似<br>
2）多个文本节点需要合并<br>

### 浏览器的CSS
1. 收集CSS规则<br>
1）遇到style标签时，我们把CSS规则保存起来<br>
2）调用CSS Parse来分析CSS规则<br>
3）仔细研究分析CSS规则的格式<br>
2. 添加调用<br>
1）创建一个元素后，立即计算CSS<br>
2）当分析一个元素时，所有CSS规则已经收集完毕<br>
3）在真实浏览器中，遇到body的style标签，需重新CSS计算的情况，此处忽略<br>
3. 获取父元素序列<br>
1）在computeCSS函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配<br>
2）我们从上一步的stack可获取本元素的所有父元素<br>
3）因为首先获取的是“当前元素”，所以获取和计算父元素匹配的顺序是从内向外的<br>
4. 拆分选择器<br>
1）选择器也要从当前元素向外排列<br>
2）复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列<br>
5. 计算选择器与元素匹配<br>
1）根据选择器的类型和元素特性，计算是否与当前元素匹配<br>
2）此处仅实现了三种基本选择器，实际的浏览器中要处理复合选择器<br>
6. 生成compute属性<br>
1）一旦选择匹配，就应用选择器到元素上，形成computedStyle<br>
7. 确定规则覆盖关系<br>
1）CSS规则根据specificity和后来优先规则覆盖<br>
2）specificity是个四元组，越左边权重越高<br>
3）一个CSS规则的specificity根据包含的简单选择器相加而成<br>
